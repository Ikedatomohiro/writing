---
name: test-driven-development
description: 機能実装やバグ修正の際に使用する。実装コードを書く前にテストを先に書く。ユーザーが「/tdd」「TDDで実装して」「テスト駆動で」と言った時に使用する。
---

# Test-Driven Development (TDD)

テストを先に書く。失敗を見る。最小限のコードで通す。

**核心原則**: テストが失敗するのを見なければ、正しいテストかどうか分からない。

**ルールの形式を破ることは、精神を破ること。**

## 使用タイミング

**常に使用**:
- 新機能
- バグ修正
- リファクタリング
- 動作変更

**例外（ユーザーの許可が必要）**:
- 使い捨てプロトタイプ
- 生成コード
- 設定ファイルのみの変更

「今回だけTDDをスキップしよう」と思った？ 止まれ。それは言い訳。

## 鉄の掟

```
失敗するテストなしにプロダクションコードを書くな
```

テストより先にコードを書いた？ 削除しろ。最初からやり直せ。

**例外なし**:
- 「参考として残す」は禁止
- 「テストを書きながら適応する」は禁止
- 見るな
- 削除とは完全削除

テストから新しく実装する。以上。

## Red-Green-Refactor サイクル

```
[RED] → [GREEN] → [REFACTOR] → [RED] → ...
```

### RED - 失敗するテストを書く

何が起きるべきかを示す最小のテストを1つ書く。

**良い例** (Python):
```python
def test_retry_failed_operations_3_times():
    attempts = 0

    def operation():
        nonlocal attempts
        attempts += 1
        if attempts < 3:
            raise Exception('fail')
        return 'success'

    result = retry_operation(operation)

    assert result == 'success'
    assert attempts == 3
```
明確な名前、実際の動作をテスト、1つのことだけ

**悪い例**:
```python
def test_retry_works():
    mock = Mock()
    mock.side_effect = [Exception(), Exception(), 'success']
    retry_operation(mock)
    assert mock.call_count == 3
```
曖昧な名前、コードではなくモックをテスト

**要件**:
- 1つの動作
- 明確な名前
- 実際のコード（モックは避けられない場合のみ）

### RED検証 - 失敗を見る

**必須。スキップ禁止。**

```bash
cd tools && uv run pytest tests/test_対象.py -v
```

確認事項:
- テストが失敗する（エラーではない）
- 失敗メッセージが期待通り
- 機能がないから失敗（タイポではない）

**テストが通った？** 既存の動作をテストしている。テストを修正。

**テストがエラー？** エラーを修正し、正しく失敗するまで再実行。

### GREEN - 最小限のコード

テストを通す最もシンプルなコードを書く。

**良い例**:
```python
async def retry_operation(fn):
    for i in range(3):
        try:
            return fn()
        except Exception as e:
            if i == 2:
                raise e
    raise RuntimeError('unreachable')
```
テストを通すのに十分なだけ

**悪い例**:
```python
async def retry_operation(
    fn,
    max_retries: int = 3,
    backoff: str = 'exponential',
    on_retry: Callable | None = None,
):
    # YAGNI（You Aren't Gonna Need It）
    ...
```
過剰設計

機能追加、他のコードのリファクタ、テスト以上の「改善」は禁止。

### GREEN検証 - 成功を見る

**必須。**

```bash
cd tools && uv run pytest tests/test_対象.py -v
```

確認事項:
- テストが通る
- 他のテストも通る
- 出力がクリーン（エラー、警告なし）

**テスト失敗？** コードを修正。テストを修正するな。

**他のテスト失敗？** 今すぐ修正。

### REFACTOR - 整理する

グリーンの後のみ:
- 重複を除去
- 名前を改善
- ヘルパーを抽出

テストをグリーンに保つ。動作は追加しない。

### 繰り返す

次の機能のために次の失敗するテストへ。

## 良いテスト

| 品質 | 良い | 悪い |
|------|------|------|
| **最小** | 1つのこと。名前に「かつ」があれば分割 | `test_validates_email_and_domain_and_whitespace` |
| **明確** | 名前が動作を説明 | `test_test1` |
| **意図を示す** | 望ましいAPIを示す | 何をすべきか不明瞭 |

## 順序が重要な理由

**「後でテストを書いて検証する」**

コード後に書いたテストは即座に通る。即座に通ることは何も証明しない:
- 間違ったことをテストしているかも
- 動作ではなく実装をテストしているかも
- 忘れたエッジケースを見逃すかも
- テストがバグを捕まえるところを見ていない

テストファーストは失敗を見ることを強制し、実際に何かをテストしていることを証明する。

**「削除はX時間の無駄」**

埋没費用の誤り。時間は既に失われた。今の選択:
- 削除してTDDでやり直す（追加X時間、高い確信）
- 残して後からテスト追加（30分、低い確信、バグの可能性）

「無駄」は信頼できないコードを残すこと。実際のテストなしの動くコードは技術的負債。

**「TDDは教条的、実用的であることは適応すること」**

TDDは実用的:
- コミット前にバグを発見（後でデバッグより速い）
- 回帰を防止（テストが即座に検知）
- 動作を文書化（テストがコードの使い方を示す）
- リファクタリングを可能に（自由に変更、テストが検知）

「実用的」ショートカット = 本番でデバッグ = 遅い。

## よくある言い訳

| 言い訳 | 現実 |
|--------|------|
| 「シンプルすぎてテスト不要」 | シンプルなコードも壊れる。テストは30秒。 |
| 「後でテストする」 | 即座に通るテストは何も証明しない。 |
| 「既に手動テストした」 | アドホック ≠ 体系的。記録なし、再実行不可。 |
| 「削除はX時間の無駄」 | 埋没費用の誤り。未検証コードは技術的負債。 |
| 「参考として残し、先にテストを書く」 | 適応してしまう。それは後からテスト。削除は削除。 |
| 「先に探索が必要」 | 良い。探索は捨てて、TDDで始める。 |
| 「テストが難しい = 設計が不明瞭」 | テストに耳を傾けよ。テストしにくい = 使いにくい。 |
| 「TDDは遅くなる」 | TDDはデバッグより速い。実用的 = テストファースト。 |

## 危険信号 - 止まって最初からやり直せ

- テストの前にコード
- 実装後にテスト
- テストが即座に通る
- なぜテストが失敗したか説明できない
- 「後で」テスト追加
- 「今回だけ」と言い訳
- 「既に手動テストした」
- 「参考として残す」または「既存コードを適応」
- 「既にX時間かけた、削除は無駄」

**これら全ては意味する: コードを削除。TDDで最初からやり直せ。**

## 例: バグ修正

**バグ:** 空のメールが受け入れられる

**RED**
```python
def test_rejects_empty_email():
    result = submit_form({'email': ''})
    assert result['error'] == 'Email required'
```

**RED検証**
```bash
$ cd tools && uv run pytest tests/test_form.py::test_rejects_empty_email -v
FAILED: AssertionError: expected 'Email required', got None
```

**GREEN**
```python
def submit_form(data: dict) -> dict:
    if not data.get('email', '').strip():
        return {'error': 'Email required'}
    # ...
```

**GREEN検証**
```bash
$ cd tools && uv run pytest tests/test_form.py::test_rejects_empty_email -v
PASSED
```

**REFACTOR**
必要に応じて複数フィールドのバリデーションを抽出。

## 検証チェックリスト

作業完了前に確認:

- [ ] すべての新しい関数/メソッドにテストがある
- [ ] 各テストが実装前に失敗するのを見た
- [ ] 各テストが期待通りの理由で失敗した（機能がない、タイポではない）
- [ ] 各テストを通す最小限のコードを書いた
- [ ] すべてのテストが通る
- [ ] 出力がクリーン（エラー、警告なし）
- [ ] テストは実際のコードを使用（モックは避けられない場合のみ）
- [ ] エッジケースとエラーをカバー

すべてにチェックできない？ TDDをスキップした。最初からやり直せ。

## 困ったとき

| 問題 | 解決策 |
|------|--------|
| テスト方法が分からない | 望むAPIを書く。アサーションを先に書く。ユーザーに聞く。 |
| テストが複雑すぎる | 設計が複雑すぎる。インターフェースを簡素化。 |
| 全部モックが必要 | コードが密結合すぎる。依存性注入を使う。 |
| セットアップが巨大 | ヘルパーを抽出。まだ複雑？設計を簡素化。 |

## デバッグとの統合

バグを見つけた？ それを再現する失敗するテストを書く。TDDサイクルに従う。テストが修正を証明し、回帰を防ぐ。

テストなしにバグを修正するな。

## 最終ルール

```
プロダクションコード → テストが存在し、先に失敗していた
そうでなければ → TDDではない
```

ユーザーの許可なしに例外なし。
